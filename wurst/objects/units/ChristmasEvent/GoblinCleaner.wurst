package GoblinCleaner

import Assets
import ChannelAbilityPreset
import LocalItemObjEditing
import ToolTipsUtils
import HashMap
import ClosureEvents
import LinkedList
import AbilityObjectCreationUtils
import ClosuresForItems
import TerrainUtils
import OrderIds
import ClosureTimers

import LocalObjectIDs
import TeleGathering
import TextTagUtils
import ColorUtils

let ABIL_START_CLEAN = compiletime(ABIL_ID_GEN.next())

let TT_EXT_ABIL = ("" +
    "Are you tired of manually cleaning up your base? Then witness this " +
    "marvelous piece of technology! Base Auto Cleaner 3000 (BAC-3000) will " +
    "clean your base in your stead! Use this ability on a camp fire and it " +
    "will start sorting your items around it.")

@compiletime function createGoblinCleaner()
    new UnitDefinition(UNIT_GOBLIN_CLEANER, UnitIds.clockwerkgoblin1)
        ..setNormalAbilities(commaList(
            ABIL_START_CLEAN,
            ABILITY_INVENTORY_1_SLOT
            )
        )
        ..setAttacksEnabled(0)
        ..setSightRadiusDay(100)
        ..setSightRadiusNight(100)
        ..setHitPointsMaximumBase(10)
        ..setCollisionSize(6.0)
        ..setName("BAC-3000")

    new ChannelAbilityPreset(ABIL_START_CLEAN, 1, true)
        ..setDummyAbility()
        ..setCooldown(1, 3)
        ..setCastRange(1, 300)
        ..presetButtonPosNormal(0, 2)
        ..setName("Cleaning protocole")
        ..setNameEnhance("Q", "Execute cleaning protocole")
        ..setTooltipLearnExtended(TT_EXT_ABIL)
        ..setIconNormal(Icons.bTNLoad)
        ..presetTargetsAllowed(lvl -> commaList(
            TargetsAllowed.sapper,
            TargetsAllowed.friend
            )
        )
        ..presetTargetTypes(Targettype.UNIT)
        ..setOptions(1, 1)

let SORT_DISTANCE_INCREMENT = 150
let SORT_DISTANCE_BASE = 45
let SORT_ANGLE_INCREMENT = 45
let MAX_SORTING_SEARCH_LOOPS = 2
let SORT_RADIUS = 900
let cleanerMap = new HashMap<unit, CleaningInstance>

class CleaningInstance
    IterableMap<int, SortingPosition> sortingPositions
    int sortDistanceOffset = SORT_DISTANCE_INCREMENT
    int nextSortAngle = 0
    LinkedList<item> itemToSort
    LinkedList<item> itemSorted
    unit target
    unit caster
    rect search
    CallbackPeriodic cb

    construct(unit whichUnit, unit target)
        this.itemToSort = new LinkedList<item>
        this.itemSorted = new LinkedList<item>
        this.sortingPositions = new IterableMap<int, SortingPosition>()
        this.caster = whichUnit
        this.target = target
        let pos = target.getPos()
        this.search = Rect(pos.x - SORT_RADIUS, pos.y - SORT_RADIUS, pos.x + SORT_RADIUS, pos.y + SORT_RADIUS)

        registerItemToSort()
        orderPickUp()
        createFadingTextTag(caster, "Cleaning protocole engaged!", COLOR_YELLOW)

        cb = doPeriodically(2.0) (CallbackPeriodic cb) ->
            if itemToSort.isEmpty()
                registerItemToSort()
                doAfter(0.1) ->
                    orderPickUp()

        EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) ->
            let itm = EventData.getManipulatedItem()
            let u = EventData.getTriggerUnit()
            if itemSorted.has(itm)
                if u == caster
                    orderSort(itm)
                else
                    itemSorted.remove(itm)

        EventListener.add(caster, EVENT_PLAYER_UNIT_DROP_ITEM) ->
            let itm = EventData.getManipulatedItem()
            if itemSorted.has(itm)
                doAfter(0.1) ->
                    orderPickUp()


        EventListener.onCast(target, ABILITY_PACK_BUILDING) (unit caster) ->
            terminateCleaning()
        EventListener.add(target, EVENT_PLAYER_UNIT_DEATH) ->
            terminateCleaning()

    function registerItemToSort()
        forItemsInRect(this.search) (item i) ->
            if i.isPickupable() and not itemSorted.has(i)
                itemToSort.add(i)

    private function getSortingPos(int itemType) returns SortingPosition

        //If a cached pos exists, return it
        if this.sortingPositions.has(itemType)
            return this.sortingPositions.get(itemType)

        //Otherwise find and create a new pos for item type
        let newPos = new SortingPosition(findPosForItem(itemType))
        sortingPositions.put(itemType, newPos)
        return newPos

    private function findPosForItem(int itemType) returns vec2
        let defaultPos = target.getPos()

        //Look for similar nearby item, multiply range by 1.1 to account for items grouping and spilling over
        let nearest = findNearestItem(defaultPos, (SORT_DISTANCE_BASE + sortDistanceOffset * MAX_SORTING_SEARCH_LOOPS * 1.1), i -> i.getTypeId() == itemType)
        if nearest != null
            return nearest.getPos()

        //Look for a new position around the fire
        for distanceOffset = this.sortDistanceOffset to MAX_SORTING_SEARCH_LOOPS * SORT_DISTANCE_INCREMENT step SORT_DISTANCE_INCREMENT
            for angleOffset = this.nextSortAngle to 360-SORT_ANGLE_INCREMENT step SORT_ANGLE_INCREMENT
                this.sortDistanceOffset = distanceOffset
                this.nextSortAngle = angleOffset
                let maybeTargetPos = defaultPos.polarOffset(angleOffset.toReal().fromDeg(), SORT_DISTANCE_BASE + distanceOffset.toReal())

                if maybeTargetPos.isTerrainWalkable()
                    this.nextSortAngle += SORT_ANGLE_INCREMENT
                    return maybeTargetPos

            this.nextSortAngle = 0

        return defaultPos

    function orderPickUp()
        let itm = itemToSort.pop()
        itemSorted.add(itm)
        if itm.getPos().distanceTo(this.target.getPos()) < SORT_RADIUS
            and itm.isPickupable()
            this.caster.issueTargetOrderById(OrderIds.smart, itm)

    function orderSort(item itm)
        let sortingPos = this.getSortingPos(itm.getTypeId())
        let finalPos = sortingPos.pos
        this.caster.dropItemPoint(itm, finalPos)

    function terminateCleaning()
        createFadingTextTag(caster, "Cleaning protocole terminated...", COLOR_YELLOW)
        destroy this

    ondestroy
        cleanerMap.getAndRemove(caster)
        destroy cb
        destroy itemToSort
        destroy itemSorted
        destroy sortingPositions


init
    EventListener.onTargetCast(ABIL_START_CLEAN) (unit caster, unit target) ->
        if cleanerMap.has(caster)
            if cleanerMap.get(caster).target != target
                destroy cleanerMap.get(caster)
                cleanerMap.put(caster, new CleaningInstance(caster, target))
            else
                cleanerMap.get(caster)
                    ..registerItemToSort()
                    ..orderPickUp()
        else
            cleanerMap.put(caster, new CleaningInstance(caster, target))
