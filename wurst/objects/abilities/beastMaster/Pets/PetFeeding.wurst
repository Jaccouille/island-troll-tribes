package PetFeeding

// Standard library imports:
import ClosureEvents
import UpgradeObjEditing
import ClosuresForItems
import ChannelAbilityPreset
import Assets

// Local imports:
import LocalObjectIDs
import Pets
import ColorUtils
import StringExtensions
import ToolTipsUtils
import LocalAssets
import HashMap
import LinkedList
import SimError
import TextTagUtils
import initlater PetTaming

// I wanted animals to have different diet, but I fear it might add too much complexity for players or tooltipping
// Kinda want to be able to feed materials to drake based on their type (e.g red drake eats flint, nether eats darkness Orb)
public let petDietMap = new HashMap<int, LinkedList<int>>()
    ..put(UNIT_ELK                     , asList(ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_TAMED_ELK               , asList(ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_JUNGLE_WOLF             , asList(ITEM_COOKED_MEAT, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_TAMED_WOLF              , asList(ITEM_COOKED_MEAT, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_TAMED_BEAR              , asList(ITEM_COOKED_MEAT, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_JUNGLE_BEAR             , asList(ITEM_COOKED_MEAT, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_HAWK_HATCHLING          , asList(ITEM_COOKED_MEAT, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_NETHER_DRAGON_HATCHLING , asList(ITEM_COOKED_MEAT, ITEM_ACORN, ITEM_MAGIC_ACORN))

public let foodMapMana = new HashMap<int, int>()
    ..put(ITEM_COOKED_MEAT, 3)
    ..put(ITEM_ACORN      , 4)
    ..put(ITEM_MAGIC_ACORN, 8)

let MANA_GAINED = 1
let HOTKEY = "D"
let ICON = LocalIcons.aTCCannibalize
let TOOLTIP = "Eat Corpse"
let TOOLTIP_EXT = "Eat a raw corpse to gain {0} energy. energy can be used to grow your pet, or increase its stats. \n".format(MANA_GAINED.toString().color(ENERGY_COLOR)) +
                    "You can upgrade any stat a total of {0} times every time your troll levels up.".format("3".color(GOLD_COLOR))

@compiletime function createManaDummyUpgrade() returns UpgradeDefinition
    return new UpgradeDefinition(UPGD_PET_EATING_ALLOWED)
        ..setName(1, "Maximum unused upgrade points reached.")

@compiletime function createAbilityFeedItemPet() returns ChannelAbilityPreset
    return new ChannelAbilityPreset(ABILITY_FEED_PET, 1, true)
        ..setManaCost(1, 0)
        ..setCastRange(1, 9999)
        ..presetTargetTypes(Targettype.NONE)
        ..setIconNormal(Icons.bTNCannibalize)
        ..setButtonPositionNormalX(1)
        ..setButtonPositionNormalY(1)
        ..setCooldown(1, 2)

public function feedPet(unit pet, unit caster, int itemId, int charges)
    let manaFromStack = (charges * foodMapMana.get(itemId)).toReal()
    let totalMana = pet.getMana() + manaFromStack

    let manaExcess = totalMana - pet.getMaxMana()
    let correctAmount = manaExcess > 0
                               ? manaFromStack - (manaExcess)
                               : manaFromStack

    pet.addMana(correctAmount)
    flashEffect(Abilities.aImaTarget, pet, "origin")

    // Create a text tag to visualize the effect.
    if correctAmount > 0
        createTeamFadingTextTag(pet, pet.getPos3Real(), "+" + correctAmount.floor().toString(), COLOR_TURQUOISE)

    if manaExcess >= 0

        // If the animal reach max mana and is neutral, add him as a pet
        if pet.getOwner() == players[PLAYER_NEUTRAL_AGGRESSIVE]
            if caster.getOwner().getPet() == null
            // Could allow pet stealing.... might be funny...
            // or u.getOwner().isEnemyOf(caster.getOwner())
                tamePet(caster.getOwner(), pet)
            else
                simError(caster.getOwner(), "Cannot tame more pet")
        else
            simError(caster.getOwner(), "This pet is full")

        // In case there's too much food sent, we create an item stack with the remaining charges
        // We could actually compute the remaning charges before and send the exact number needed, but I imagine funny
        // situation will come out of this behavior
        // Using floor to make sure atleast 1 charge is consumed
        let leftover = ((manaExcess) / foodMapMana.get(itemId)).floor()
        if leftover > 0
            createItem(itemId, pet.getPos())..setCharges(leftover)

function petEat(unit caster)
    let nearestFood = findNearestItem(caster.getPos(), 250, i -> petDietMap.get(caster.getTypeId()).has(i.getTypeId()))

    if caster.getMissingMana() == 0
        simError(caster.getOwner(), "This pet cannot eat anymore")
    else if nearestFood != null
        caster.setFacing(caster.getPos().angleTo(nearestFood.getPos()))
        feedPet(caster, caster, nearestFood.getTypeId(), nearestFood.getCharges())
        nearestFood.remove()
    else
        simError(caster.getOwner(), "There's nothing edible for this pet to eat")

init
    EventListener.onCast(ABILITY_FEED_PET) (unit caster) ->
        petEat(caster)
