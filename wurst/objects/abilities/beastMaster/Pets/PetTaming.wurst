package PetTaming

// Standard library imports:
import ClosureEvents
import AbilityObjEditing
import Assets
import ObjectIds
import Lodash
import TimerUtils
import ClosureForGroups

// Local imports:
import ColorUtils
import LocalAssets
import LocalObjectIDs
import Pets
import StringExtensions
import ToolTipsUtils
import PlayerExtensions
import LinkedList
import HashMap
import SimError
import UnitExtensions
import Transformation
import PetUpgradeHandler

let PET_MAX_MANA = 6

let PETS_TT = map((animal, _) -> animal.color(COLOR_YELLOW), asList("Elk", "Wolf", "Bear")).joinBy(", ")

let ABIL_TT_EXT = "Tames a baby animal. The following animals killed by the " + "Beast Master".color(HIGHLIGHT_COLOR) + " will leave a baby behind: "
                  + PETS_TT + "."
                  + "\n\nYou can tame only 1 animal at once.".color(COLOR_RED)

let petFeedMap = new HashMap<int, int>()
    ..put(UNIT_ELK                    , 2)
    ..put(UNIT_JUNGLE_WOLF            , 8)
    ..put(UNIT_JUNGLE_BEAR            , 12)
    ..put(UNIT_PANTHER                , 20)
    ..put(UNIT_HAWK_HATCHLING         , 4)
    ..put(UNIT_NETHER_DRAGON_HATCHLING, 8)


function createPetTameSpell(int newAbilId) returns AbilityDefinitionCharm
    return new AbilityDefinitionCharm(newAbilId)
        ..setIconNormal(LocalIcons.bTNTamePet)
        ..setCooldown(1, 10.0)
        ..setManaCost(1, 0)
        ..setHeroAbility(false)
        ..setName("Tame Pet")
        ..setCastRange(1, 2000.0)
        ..setArtTarget(Abilities.controlMagicTarget)
        ..setTargetsAllowed(1, commaList(
                TargetsAllowed.nonhero,
                TargetsAllowed.organic
            ))
        ..setTooltipNormalExtended(1, ABIL_TT_EXT)
        ..setRequirements(UPGD_PET_TAMED_FALSE.toRawCode())
        ..setEditorSuffix("(Wurst)")
        ..setAnimationNames("Attack - 1")

@compiletime function createBasePetTameSpell() returns AbilityDefinitionCharm
    return createPetTameSpell(ABILITY_PET_TAME)
    ..setButtonPositionNormalX(0)
    ..setButtonPositionNormalY(0)
    ..setHotkeyNormal("Q")
    ..setTooltipNormal(1, makeToolTipNorm("Q", "Tame"))

@compiletime function createShapeShifterPetTameSpell() returns AbilityDefinitionCharm
    return createPetTameSpell(ABILITY_PET_TAME_SHAPESHIFTER)
    ..setButtonPositionNormalX(0)
    ..setButtonPositionNormalY(1)
    ..setHotkeyNormal("A")
    ..setTooltipNormal(1, makeToolTipNorm("A", "Tame"))

// Gonna make the parabola formula work!
class foodProjectile
    use TimedLoop
    unit u
    unit target
    vec3 targetPos

    effect efx

    vec3 pos
    real speed
    real elapse_time = 0

    vec3 initPos
    real duration
    real distance
    angle angle
    real displacement
    real gravity

    real p
    real a
    real b
    real c
    real v0
    real teta
    real f
    real v
    real n

    real arc
    real d

    vec3 vel
    vec3 acc

    construct(unit u, unit target, string efxArt, real speed)
        this.u = u
        this.target = target
        this.targetPos = target.getPos3Real()

        this.speed = speed
        this.pos = u.getPos().polarOffset(u.getPos().angleTo(target.getPos()), 50).withTerrainZ()
        this.initPos = pos
        this.efx = addEffect(efxArt, this.pos)
        this.duration = initPos.distanceTo2d(targetPos) / speed
        this.distance = initPos.distanceTo2d(targetPos)
        this.gravity = -100
        // this.angle = (45).asAngleDegrees()


        // this.p = - gravity * (distance * distance)
        // this.a = p / (2 * (45..cos() * 45..cos()))
        // this.b = distance / 2
        // this.c = pos.z - targetPos.z

        // this.f = -b -c
        // this.v = -a / (-b -c)
        // this.v0 = SquareRoot(v)
        // this.teta = b / (v0 * angle.cos())

        print("hello")
        this.arc = 0.250
        this.d = initPos.distanceTo2d(targetPos)
        print("y: " + (targetPos.y - initPos.y).toString())
        print("x: " + (targetPos.x - initPos.x).toString())
        this.a = Atan2(targetPos.y - initPos.y, targetPos.x - initPos.x)
        print("distance: " + d.toString())
        print("atan: " + a.toString())

        this.acc.z = (-8*arc*speed*speed/d)
        print("acc.z: " + acc.z.toString())
        this.vel = vec3(
            speed * Cos(a),
            speed * Sin(a),
            (-acc.z * (d / speed) / 2 + (targetPos.z - initPos.z) / (d / speed))
            )
        print("ini vel: " + vel.toString())
        this.acc.z = acc.z * ANIMATION_PERIOD * ANIMATION_PERIOD
        print("acc.z after : " + acc.z.toString())
        this.vel = this.vel.op_mult(ANIMATION_PERIOD)
        print("end vel: " + vel.toString())

        this.startTimedLoop()



    override function onTimedLoop()
        forUnitsInRange(pos.toVec2(), 50) (unit u) ->
            if u.getTypeId() == UNIT_ELK
                print("ded")
                stopTimedLoopAndDestroy()
        //vec3 newPos = this.pos.offset2d(pos.angleTo2d(targetPos), speed * ANIMATION_PERIOD)

        vel = vel.op_plus(acc.op_mult(1. * 1.))
        pos = pos.op_plus(vel.op_mult(1))

        efx.setPos(pos)
        let anglexy = pos.angleTo2d(targetPos)
        efx.setYaw(anglexy)
        // pos = newPos
        elapse_time += ANIMATION_PERIOD
        // let x = ((initPos.x - pos.x).squared() + (initPos.y - pos.y).squared()) * 0.5
        // let x1 = initPos.distanceTo2d(pos)

        // let travX = ((speed * speed) * (2 * angle.sin())) / (2 * 100)
        // let travT = (2 * speed * angle.sin()) / 100

        // Guillaume
        // print("elapsed time : " + elapse_time.toString())
        // print("distance: " + this.distance.toString())
        // print("x1: " + targetPos.x.toString())
        // print("x0: " + initPos.x.toString())
        // print("angle cos : " + angle.cos().toString())
        // print("angle sin : " + angle.sin().toString())
        // print("angle cos deg : " + (45..cos().toString()))
        // print("angle sin deg : " + (45..sin().toString()))
        // print("check 2 x cos: " + (2 * (45..cos() * 45..cos())).toString())
        // print("check 2 x cosÂ²: " + (2 * (angle.cos() * angle.cos())).toString())
        // print("p: " + p.toString())
        // print("a: " + a.toString())
        // print("b: " + b.toString())
        // print("c: " + c.toString())
        // print("f: " + f.toString())
        // print("v: " + v.toString())
        // print("v0: " + v0.toString())
        // print("v00: " + SquareRoot(v.abs()).toString())
        // print("teta: " + teta.toString())
        // print("gravity: " + gravity.toString())

        // // displacement Z?
        // print("d: " + (0.5 * ((gravity) * (teta * teta)) + v0 * angle.sin() * teta + initPos.z).toString())

        // // distance
        // print("dist: " + (v0 * angle.cos() * teta).toString())

        // // maxH Time
        // let tH =(-v0 * angle.sin()) / gravity
        // print("tH: " + tH.toString())

        // // maxH
        // print("maxH: " + (0.5 * (gravity * (tH * tH)) + v0 * angle.sin() * tH + initPos.z ).toString())
        // print("maxH2: " + (((v0 * v0) * (angle.sin() * angle.sin())) / (2 * gravity)).toString() )

    ondestroy
        this.efx.destr()

function feedAnimal(unit caster, unit target)
    let inventory = caster.getInventory()
    let meatInv = inventory.filter(elem -> elem.getTypeId() == ITEM_COOKED_MEAT)
    meatInv.pop()..remove()
    caster.setFacing(caster.getPos().angleTo(target.getPos()))
    //caster.setAnimation("Attack - 1")
    new foodProjectile(caster, target, Abilities.keeperGroveMissile, 600)


function onTame(unit caster, unit target)
    // Record the owner of the new unit.
    let owner = caster.getOwner()

    feedAnimal(caster, target)

    // if petFeedMap.has(target.getTypeId())
    //     let foodRequired = petFeedMap.get(target.getTypeId())

    //     let inventory = caster.getInventory()
    //     let meatInv = inventory.filter(elem -> elem.getTypeId() == ITEM_COOKED_MEAT)
    //     for elem in meatInv
    //         var stack = elem.getCharges()
    //         print(elem.getCharges())

    // Look up the growth chain for the pet.
    // let chain = target.getPetGrowthChain()

    // // Look up the next unit along the chain.
    // let next = chain.get(chain.indexOf(target.getTypeId()) + 1)

    // transformUnit(target, next)

    // owner.addPet(target)
    // petUpgradeHandlerInstance.put(target, new PetUpgradeHandler(caster, target))

    // owner.setTechResearched(UPGD_PET_TAMED_TRUE, 1)
    // owner.setTechResearched(UPGD_PET_TAMED_FALSE, 0)

    // else
    //     simError(caster.getOwner(), "Cannot pet this target")
    //     return


init
    EventListener.onTargetCast(ABILITY_PET_TAME) (unit caster, unit target) ->
        onTame(caster, target)
    EventListener.onTargetCast(ABILITY_PET_TAME_SHAPESHIFTER) (unit caster, unit target) ->
        onTame(caster, target)
