package Mammoth

// Standard library imports:
import ClosureForGroups
import LinkedList
import MapBounds
import Sounds

// Local imports:
import Hostile
import LocalObjectIDs
import LocalAssets
import StringExtensions
import PingMinimap
import ColorUtils

// TODO: Allow the respawn mode to register events.
public destructable MAMMOTH_GATE

public class Mammoth extends Hostile
    private static let unitTypeId = UNIT_MAMMOTH
    private static thistype instance

    static function initialize()
        register(unitTypeId, mammoth -> new Mammoth(mammoth))

    static function getInstance() returns thistype
        return instance

    var dead = false

    construct(unit whichUnit)
        super(whichUnit)

    override function postCreate()
        super.postCreate()

        if instance == null
            instance = this

    override function getDrops() returns LinkedList<int>
        let drops = super.getDrops()
            ..add(ITEM_HORN_MAMMOTH)
            ..add(ITEM_MEDALLION_COURAGE)
            ..add(ITEM_BONE)
            ..add(ITEM_BONE)
            ..add(ITEM_BONE)
            ..add(ITEM_BONE)
            ..add(ITEM_BONE)
        return drops

    override function getNumCorpses() returns int
        return 16

    override function onDeath()
        // TODO : Wrap this up in a Boss entity class?
        PlaySound(Sounds.warning)
        printTimed(("The " + getUnit().getName() + " has been killed!").color("red".toColor()), 5)
        pingMinimap(getUnit().getPos(), 5, COLOR_YELLOW, PingMinimapStyle.ATTACK)
        dead = true
        super.onDeath()


    override function postDeath()
        getUnit().remove()

    function isDead() returns boolean
        return dead


init
    Mammoth.initialize()

    forDestructablesInRect(boundRect) (destructable d) ->
        if d.getTypeId() == DestructibleIds.ruinedGateDiagonal2
            MAMMOTH_GATE = d
